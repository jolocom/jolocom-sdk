{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Jolocom Software Development Kit - Facilitating applications to manage and interact with digital identities. The Jolocom SDK is a toolkit for managing SSI Agents and the interactions carried out between them, allowing services and clients to work together seamlessly with minimal trust assumptions and maximum security. For optimal utility and interoperability, the SDK builds upon implementations of the following specifications: W3C Decentralized Identifiers (DIDs) : To provide identifiers for Agents managed by the SDK. W3C Verifiable Credentials (VCs) : To allow for verifiable attestations to be exchanged and utilised by Agents. The SDK is composed of a few core concepts which work together to provide a framework for making use of Decentralized Identities, and provides an interface to the SSI ecosystem via Agents and Interactions. It is designed to streamline the creation, validation, authentication and processing of signed messages in order to facilitate different protocols enacted between Agents. Messages created by Agents are secured by the security mechanism of their chosen DID Method . The SDK itself functions as an Agent Factory. It manages a storage connection and a collection of registered DID Methods, providing storage access and resolution capabilities to the Agents which it creates. This documentation contains information on how to: Install, configure and instantiate the Jolocom SDK Use an instance of the Jolocom SDK to create Agents Use the created Agents to Participate in various SSI interactions Create Verifiable Credentials For API documentation, see the API docs .","title":"Introduction"},{"location":"#introduction","text":"Jolocom Software Development Kit - Facilitating applications to manage and interact with digital identities. The Jolocom SDK is a toolkit for managing SSI Agents and the interactions carried out between them, allowing services and clients to work together seamlessly with minimal trust assumptions and maximum security. For optimal utility and interoperability, the SDK builds upon implementations of the following specifications: W3C Decentralized Identifiers (DIDs) : To provide identifiers for Agents managed by the SDK. W3C Verifiable Credentials (VCs) : To allow for verifiable attestations to be exchanged and utilised by Agents. The SDK is composed of a few core concepts which work together to provide a framework for making use of Decentralized Identities, and provides an interface to the SSI ecosystem via Agents and Interactions. It is designed to streamline the creation, validation, authentication and processing of signed messages in order to facilitate different protocols enacted between Agents. Messages created by Agents are secured by the security mechanism of their chosen DID Method . The SDK itself functions as an Agent Factory. It manages a storage connection and a collection of registered DID Methods, providing storage access and resolution capabilities to the Agents which it creates. This documentation contains information on how to: Install, configure and instantiate the Jolocom SDK Use an instance of the Jolocom SDK to create Agents Use the created Agents to Participate in various SSI interactions Create Verifiable Credentials For API documentation, see the API docs .","title":"Introduction"},{"location":"guides/agents/","text":"Agents An Agent represents an actor holding identity and capable of interacting with other Agents. It is the core of any service or application built with the SDK. Agents are suitable for all roles in any SSI interaction, and can be used for client-server or P2P style services. To create/load an Agent, a JolocomSDK instance is needed, refer to the Configuration section for details. Agent Identity Each Agent possesses an Identity (representing DID Document), that must be created or loaded from storage to initialize the Agent. Refer to the Identity section for more details. Agent Interactions Agents interact together by engaging in Interaction Flows . Each interaction flow defines a set of signed messages to be exchanged in a certain order between 2 or more Agents. The messages are signed and verified using the keys associated with each Agent's DID Document. Common Interactions Flows are: Authentication Authorization Verifiable Credential Creation Issuance and Receipt of Verifiable Credentials Requesting, Providing and Verifying of Verifiable Credentials Examples Below, we see an example setup of two Agents which will be used for examples in this documentation. These Agent instances can run within the same Node process, however for this case they can be imagined to be running on a client-server model, where Alice is the server and Bob is the client. Alices Agent loading: // The Alice Agent (did:jolo:alice) is loaded from the sdk storage const alice = await sdk.loadIdentity('alicesPassword', 'did:jolo:alice') Bob Agent creation: // The Bob Agent is randomly generated using the 'jun' DID method const bob = await sdk.createNewAgent('bobsPassword', 'jun') Now that our Agents are instantiated, let's see how they can be used to set up Interaction Flows .","title":"Agents"},{"location":"guides/agents/#agents","text":"An Agent represents an actor holding identity and capable of interacting with other Agents. It is the core of any service or application built with the SDK. Agents are suitable for all roles in any SSI interaction, and can be used for client-server or P2P style services. To create/load an Agent, a JolocomSDK instance is needed, refer to the Configuration section for details.","title":"Agents"},{"location":"guides/agents/#agent-identity","text":"Each Agent possesses an Identity (representing DID Document), that must be created or loaded from storage to initialize the Agent. Refer to the Identity section for more details.","title":"Agent Identity"},{"location":"guides/agents/#agent-interactions","text":"Agents interact together by engaging in Interaction Flows . Each interaction flow defines a set of signed messages to be exchanged in a certain order between 2 or more Agents. The messages are signed and verified using the keys associated with each Agent's DID Document. Common Interactions Flows are: Authentication Authorization Verifiable Credential Creation Issuance and Receipt of Verifiable Credentials Requesting, Providing and Verifying of Verifiable Credentials","title":"Agent Interactions"},{"location":"guides/agents/#examples","text":"Below, we see an example setup of two Agents which will be used for examples in this documentation. These Agent instances can run within the same Node process, however for this case they can be imagined to be running on a client-server model, where Alice is the server and Bob is the client. Alices Agent loading: // The Alice Agent (did:jolo:alice) is loaded from the sdk storage const alice = await sdk.loadIdentity('alicesPassword', 'did:jolo:alice') Bob Agent creation: // The Bob Agent is randomly generated using the 'jun' DID method const bob = await sdk.createNewAgent('bobsPassword', 'jun') Now that our Agents are instantiated, let's see how they can be used to set up Interaction Flows .","title":"Examples"},{"location":"guides/credentials/","text":"Verifiable Credentials Verifiable Credentials represent information that one Identifier is asserting to be true about another Identifier. These statements are authenticated by verifying the signatures made on them by the issuer. Credentials can be created by Agents. Because they have a structured semantic meaning, each Verifiable Credential type must be defined in terms of a context. This is important, else the term will not appear in the signed data and will not be secured by the proof. This context is a mapping of terms found in the Credential to URIs which represent the meaning of the term. An example Credential creation is as follows, note that the simpleExampleCredMetadata constitutes the definition of the Credential type and should be re-used: const simpleExampleCredMetadata = { type: ['Credential', 'SimpleExampleCredential'], name: 'Example Name and Age', context: [ { SimpleExample: 'https://example.com/terms/SimpleExampleCredential', schema: 'https://schema.org/', age: 'schema:age', name: 'schema:name', }, ], } const alicesCredAboutBob = await alice.signedCredential({ metadata: simpleExampleCredMetadata, subject: bobsDID, claim: { age: 25, name: 'Bob', }, }) In this simple example, one of our Agents (Alice) is creates a credential with Bob as the subject, stating that his age is 25 and that his name is Bob. For details on how to actually transfer this credential from Alice to Bob (Issuance) or make use of the credential (Verification), see the Credential Issuance and Credential Verification sections. For detailed documentation on defining Verifiable Credential types, see the Credentials section of the Jolocom Library documentation.","title":"Verifiable Credentials"},{"location":"guides/credentials/#verifiable-credentials","text":"Verifiable Credentials represent information that one Identifier is asserting to be true about another Identifier. These statements are authenticated by verifying the signatures made on them by the issuer. Credentials can be created by Agents. Because they have a structured semantic meaning, each Verifiable Credential type must be defined in terms of a context. This is important, else the term will not appear in the signed data and will not be secured by the proof. This context is a mapping of terms found in the Credential to URIs which represent the meaning of the term. An example Credential creation is as follows, note that the simpleExampleCredMetadata constitutes the definition of the Credential type and should be re-used: const simpleExampleCredMetadata = { type: ['Credential', 'SimpleExampleCredential'], name: 'Example Name and Age', context: [ { SimpleExample: 'https://example.com/terms/SimpleExampleCredential', schema: 'https://schema.org/', age: 'schema:age', name: 'schema:name', }, ], } const alicesCredAboutBob = await alice.signedCredential({ metadata: simpleExampleCredMetadata, subject: bobsDID, claim: { age: 25, name: 'Bob', }, }) In this simple example, one of our Agents (Alice) is creates a credential with Bob as the subject, stating that his age is 25 and that his name is Bob. For details on how to actually transfer this credential from Alice to Bob (Issuance) or make use of the credential (Verification), see the Credential Issuance and Credential Verification sections. For detailed documentation on defining Verifiable Credential types, see the Credentials section of the Jolocom Library documentation.","title":"Verifiable Credentials"},{"location":"guides/dev_test_formatting/","text":"Development Clone the sdk repository to your computer. cd into the directory and run yarn or yarn install from your terminal to install the required packages. To run a repl, use yarn repl . Testing We use Jest for unit tests. To run unit tests, with watch and testing coverage display enabled: yarn test --watch --coverage Code Style and Formatting We use ESLint and Prettier to keep a consistent style across the codebase. There are plugins available for a range of IDEs and text editors; automatic formatting on save is also supported in some editors. yarn format will format files automatically as much as possible. Copyright (C) 2014-2020 JOLOCOM GmbH","title":"Dev test formatting"},{"location":"guides/dev_test_formatting/#development","text":"Clone the sdk repository to your computer. cd into the directory and run yarn or yarn install from your terminal to install the required packages. To run a repl, use yarn repl .","title":"Development"},{"location":"guides/dev_test_formatting/#testing","text":"We use Jest for unit tests. To run unit tests, with watch and testing coverage display enabled: yarn test --watch --coverage","title":"Testing"},{"location":"guides/dev_test_formatting/#code-style-and-formatting","text":"We use ESLint and Prettier to keep a consistent style across the codebase. There are plugins available for a range of IDEs and text editors; automatic formatting on save is also supported in some editors. yarn format will format files automatically as much as possible. Copyright (C) 2014-2020 JOLOCOM GmbH","title":"Code Style and Formatting"},{"location":"guides/identity/","text":"Identity Creating an Identity To provision an Agent with a new random identity (i.e. DID and set of keys), the following function can be used: sdk.createNewAgent('demoPassword', 'jolo') Based on the DID Method the Agent is configured to use, the appropriate identity creation / \"anchoring\" operations are executed (e.g. creating and broadcasting Blockchain transactions, interfacing with various distributed storage backends, etc.). If succesfull, the function should return the DID Document, and the corresponding signing keys, for the newly created identity. Besides returning the data associated with the new identity, the Agent will also persist the created encrypted wallet (containing keys associated with the identity) and DID Document locally (allowing for the identity to be reused at later points), using the storage backend. Two optional arguments can be provided to the createNewAgent function: passwordOrStore - The SDK makes use of a Password Store component, used for persisting secrets (e.g. the symmetric encryption key used to encrypt / decrypt the contents of the user's Wallet). A custom implementation satisfying the IPasswordStore interface can be passed at this point. In case the argument is of type string , a NaivePasswordStore will be instantiated with the provided password. In case no argument is provided, the aforementioned NaivePasswordStore is initiated with a encryption random password. For an example integration with react-native, see the JolocomKeychainPasswordStore . didMethodName - The DID Method used by the Agent. This DID Method will be used when creating an identity for the agent, as well as when recovering an identity from seed material. The Agent will still retain the ability to resolve across all DID Methods supported by the SDK. In case no argument is provided the DID Method registered as default on the SDK instance is used. createFromMnemonic agent.createFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) In case deterministic identity creation is desired, the createFromMnemonic method can be used. This function allows for the deterministic creation of a DID, and the associated keys. A BIP39 compliant mnemonic can be passed in. In case the used registrar does not implement the recoverFromSeed method, an error is thrown. The deterministic derivation of keys from a seed is delegated to the registrar implementation. Internally, BIP32, SLIP0010, or other specifications can be used. The registrar implementation encapsulates the specification, as well as the metadata required for derivation (e.g. paths, indexes, etc.) It is important to note that this function will attempt register a new DID with the DID method configured on the Agent. For a non-registering equivalent, see load from mnemonic . Once the keys and the DID have been derived, the registrar module is used to register the identity on the corresponding network (depending on the DID method used). In case the identity is already registered, an error is thrown, to prevent accidental identity updates. In case the desired functionality is to register the identity regardless of whether it's already registered on the ledger, a second boolean argument shouldOverwrite can be set to true Loading an Identity To provision the Agent with a previously created identity, the following function can be used: sdk.loadIdentity('demoPassword', 'did:jolo:aaa...fff') If a DID is provided, the method will attempt to find the associated encrypted wallet / DID Document entries using the storage interface. In case no entries have been found, an error is thrown. In case no argument is provided to the function, the first identity found is used. Note that the password or password store provided should match the password used to previously encrypt the Identity being loaded. loadFromMnemonic agent.loadFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) In case deterministic identity recovery is desired, the loadFromMnemonic method can be used. This function allows for the deterministic re-creation of a DID, and the associated keys. It is the non-registering equivalent of create from mnemonic . Once the keys and the DID have been derived, the resolver module is used to ensure that the identity is \"anchored\" (the meaning and implementation of this functionality is defined by the DID Method). In case the identity can not be resolved, an error is thrown. This method can be used to \"recover\" control over an existing identity, given only the BIP39 seed phrase (i.e. the same seed phrase used in the createFromMnemonic call).","title":"Identity"},{"location":"guides/identity/#identity","text":"","title":"Identity"},{"location":"guides/identity/#creating-an-identity","text":"To provision an Agent with a new random identity (i.e. DID and set of keys), the following function can be used: sdk.createNewAgent('demoPassword', 'jolo') Based on the DID Method the Agent is configured to use, the appropriate identity creation / \"anchoring\" operations are executed (e.g. creating and broadcasting Blockchain transactions, interfacing with various distributed storage backends, etc.). If succesfull, the function should return the DID Document, and the corresponding signing keys, for the newly created identity. Besides returning the data associated with the new identity, the Agent will also persist the created encrypted wallet (containing keys associated with the identity) and DID Document locally (allowing for the identity to be reused at later points), using the storage backend. Two optional arguments can be provided to the createNewAgent function: passwordOrStore - The SDK makes use of a Password Store component, used for persisting secrets (e.g. the symmetric encryption key used to encrypt / decrypt the contents of the user's Wallet). A custom implementation satisfying the IPasswordStore interface can be passed at this point. In case the argument is of type string , a NaivePasswordStore will be instantiated with the provided password. In case no argument is provided, the aforementioned NaivePasswordStore is initiated with a encryption random password. For an example integration with react-native, see the JolocomKeychainPasswordStore . didMethodName - The DID Method used by the Agent. This DID Method will be used when creating an identity for the agent, as well as when recovering an identity from seed material. The Agent will still retain the ability to resolve across all DID Methods supported by the SDK. In case no argument is provided the DID Method registered as default on the SDK instance is used.","title":"Creating an Identity"},{"location":"guides/identity/#createfrommnemonic","text":"agent.createFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) In case deterministic identity creation is desired, the createFromMnemonic method can be used. This function allows for the deterministic creation of a DID, and the associated keys. A BIP39 compliant mnemonic can be passed in. In case the used registrar does not implement the recoverFromSeed method, an error is thrown. The deterministic derivation of keys from a seed is delegated to the registrar implementation. Internally, BIP32, SLIP0010, or other specifications can be used. The registrar implementation encapsulates the specification, as well as the metadata required for derivation (e.g. paths, indexes, etc.) It is important to note that this function will attempt register a new DID with the DID method configured on the Agent. For a non-registering equivalent, see load from mnemonic . Once the keys and the DID have been derived, the registrar module is used to register the identity on the corresponding network (depending on the DID method used). In case the identity is already registered, an error is thrown, to prevent accidental identity updates. In case the desired functionality is to register the identity regardless of whether it's already registered on the ledger, a second boolean argument shouldOverwrite can be set to true","title":"createFromMnemonic"},{"location":"guides/identity/#loading-an-identity","text":"To provision the Agent with a previously created identity, the following function can be used: sdk.loadIdentity('demoPassword', 'did:jolo:aaa...fff') If a DID is provided, the method will attempt to find the associated encrypted wallet / DID Document entries using the storage interface. In case no entries have been found, an error is thrown. In case no argument is provided to the function, the first identity found is used. Note that the password or password store provided should match the password used to previously encrypt the Identity being loaded.","title":"Loading an Identity"},{"location":"guides/identity/#loadfrommnemonic","text":"agent.loadFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) In case deterministic identity recovery is desired, the loadFromMnemonic method can be used. This function allows for the deterministic re-creation of a DID, and the associated keys. It is the non-registering equivalent of create from mnemonic . Once the keys and the DID have been derived, the resolver module is used to ensure that the identity is \"anchored\" (the meaning and implementation of this functionality is defined by the DID Method). In case the identity can not be resolved, an error is thrown. This method can be used to \"recover\" control over an existing identity, given only the BIP39 seed phrase (i.e. the same seed phrase used in the createFromMnemonic call).","title":"loadFromMnemonic"},{"location":"guides/interaction_flows/","text":"Interaction Flows Interaction Flows are the protocols which Agents use to communicate with each other. With them, services can be easily provided and consumed. In practice, they work by using Agents to produce and consume messages, with an Interaction Manager within each Agent handling the validation and storage for each Interaction. Each interaction is defined by: The Roles played by Agents participating in the interaction The set of Message types associated with the type of interaction The set of rules associated with the type of interaction which determine the validity of new messages given the previous messages Peer Resolution | Using another Agent as a Resolver Peer resolution consists of a simple request-response message exchange, where the Requester asks the Resolver to perform DID resolution and return the result. Roles Requester: Agent who requests the resolution of a DID Resolver: Agent who resolves the given DID (or their own) and returns the result Messages Resolution Request: The Requester broadcasts a message which may or may not contain a DID. Resolution Result: If the message contains a DID, the Resolver resolves the DID and returns the DID Resolution Result . Otherwise, the Resolver returns the result of resolving it's own DID. This is intended for the special case of \"local\" DID methods, which do not have a globally resolvable state. Examples A simple Peer Resolution flow between our two Agents from the Identity Management example looks as follows: const aliceResRequest = await alice.createResolutionRequest({ description: 'introduce yourself', callbackURL: 'https://example.com/onboarding', }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceResRequest) const bobsResResponse = await bobsInteraction.createResolutionResponse() // ------- Bob's response is received by Alice ------- // // this adds Bob's identity data (a Key Event Log) to Alice's storage, such that she can now resolve his DID and verify signatures made by him const alicesInteraction = await alice.processJWT(bobsResResponse.encode()) Peer resolution allows for the resolution of Identifiers which rely on a local state proof (e.g. KERI/ did:jun and did:peer ) instead of a globally resolvable state. The successful result of resolving such Identifiers is cached by default by the SDK, and they are resolvable by any Agent instance which shares the same EventDB. Think of such a protocol as an \"introduction\" or \"onboarding\" of a private DID into a backend system. Services which are intended for consumption by natural persons are encouraged to provide at least one method for Agents to resolve themselves using this flow, as these \"local\" Identifiers are designed to solve critical GDPR and User privacy issues affecting DID methods which rely on a global shared state like Blockchains. Authentication | Proving control over an Identifier. The Authentication flow consists of a simple request-response message exchange, where the contents of the response must match those of the request. Because all Messages are signed and authenticated, the response functions as proof of control by nature of being correctly signed by the keys listed in the DID Document of the issuer. Because of this, in scenarios where a more complex functionality (e.g. Credential Verification) is needed, an additional Authentication flow is not necessary. Roles Verifier: Agent who requests and verifies the Authenticity of the Authenticator Authenticator: Agent who proves control over their Identifier Messages Authentication Request: The Verifier broadcasts containing only an optional description of the purpose of the authentication. Authentication Response: Contains the same content as the Request. Examples A simple Authentication flow between our two Agents looks as follows: const authRequest = await alice.authRequest({ callbackURL: 'https://example.com/auth', description: 'are you bob?', }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(authRequest) const bobsAuthResponse = await bobsInteraction.createAuthenticationResponse() // ------- Bob's response is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsAuthResponse.encode()) Authorization | Giving consent or permission. The Authorization flow consists of a simple request-response message exchange, where the Initiator requests authorization from the Authorizer to carry out some action. It is similar to the Authentication flow in structure, however the intent of the interaction is different, and it will render differently in the Jolocom Smartwallet. Authentication is about proving the Identity of an agent (e.g. SSO), while Authorization is about giving permission or privilege for a service to act on an agents behalf. Roles Authorized: Agent requesting Authorization to perform some action Authorizer: Agent granting Authorization to the Authorized Messages Authorization Request: The Authorized broadcasts a message representing the intent of the action which permission is required for. Authorization Response: The Authorizer responds with a message containing the same contents as the Request as consent. Examples A simple Authorization flow between our two Agents from before looks as follows: const aliceAuthZRequest = await alice.authorizationRequestToken({ description: 'Front Door', imageURL: 'https://example.com/lockImage.png', action: 'Open the door', callbackURL: 'https://example.com/authz/', }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceAuthZRequest) const bobsAuthZResponse = await bobsInteraction.createAuthorizationResponse() // ------- Bob's response is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsAuthZResponse.encode()) Verifiable Credential Issuance | Creating an authenticated statement about an Identifier. The Issuance flow consists of a three step message exchange between two parties, the Issuer and the Holder. Roles Issuer: Agent who offers and issues one or more Verifiable Credentials Holder: Agent who selects and receives one or more Verifiable Credentials Messages Credential Offer: The Issuer broadcasts a message containing a list of credential types offered for issuance in this interaction, each with it's own list of requirements which must be satisfied by the Holder in order to qualify for the credential. Credential Selection: The Holder responds with a message containing a list of selected credentials with associated data for satisfying requirements. Credential Issuance: The Issuer responds with a message containing a list of newly issued credentials corrosponding to the selected set. Examples In this simple example, Alice is issuing Bob the Credential she created for him in the Verifiable Credentials section: const aliceCredOffer = await alice.credentialOffer({ callbackURL: 'https://example.com/issuance', offeredCredentials: [ { type: 'SimpleExampleCredential', }, ], }) // ------- the offer is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceCredOffer) const bobsCredSelection = await bobsInteraction.createCredentialOfferResponseToken( [{ type: 'SimpleExampleCredential' }], ) // ------- Bob's selection is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsCredSelection.encode()) const alicesIssuance = await alicesInteraction.createCredentialReceiveToken( alicesCredAboutBob, ) // ------- Bob Receives and stores the newly issued Credential ------- // // Note that storage of the credential is handled automatically by the SDK const bobReceives = await bob.processJWT(alicesIssuence.encode()) Credential Verification | Proving a set of statements about an Identifier. The Credential Verification flow is a simple request-response message exchange between the Verifier and the Prover. Roles Verifier: Agent who requests a set of Verifiable Credentials with associated requirements. Prover: Agent who provides a set of Verifiable Credentials attempting to satisfy the request Messages Credential Request: The Verifier broadcasts a message containing a list of credential types, each with it's own list of requirements to be satisfied by the Prover. Credential Response: The Prover responds with a list of credentials which should satisfy the corrosponding requirements in the Credential Request. Examples In this example, Alice is requesting from Bob the same type of Credential she issued for him in the Credential Issuance section: const aliceCredRequest = await alice.credentialRequestToken({ callbackURL: 'https://example.com/request', credentialRequirements: [ { type: ['SimpleExampleCredential'], constraints: [greater('age', 18), is('name', 'Bob')], }, ], }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceAuthZRequest) const bobsAuthZResponse = await bobsInteraction.createCredentialResponse([ alicesCredAboutBob.id, // use the ID from the aliceCredAboutBob instance ]) // ------- Bob's response is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsAuthZResponse.encode()) Note that the response argument is a list of Credential IDs. Each Credential has an ID which is a hash of the credential. The response creation will fetch each credential referenced in the list from the Agent Storage and include them in the response.","title":"Interaction Flows"},{"location":"guides/interaction_flows/#interaction-flows","text":"Interaction Flows are the protocols which Agents use to communicate with each other. With them, services can be easily provided and consumed. In practice, they work by using Agents to produce and consume messages, with an Interaction Manager within each Agent handling the validation and storage for each Interaction. Each interaction is defined by: The Roles played by Agents participating in the interaction The set of Message types associated with the type of interaction The set of rules associated with the type of interaction which determine the validity of new messages given the previous messages","title":"Interaction Flows"},{"location":"guides/interaction_flows/#peer-resolution","text":"| Using another Agent as a Resolver Peer resolution consists of a simple request-response message exchange, where the Requester asks the Resolver to perform DID resolution and return the result.","title":"Peer Resolution"},{"location":"guides/interaction_flows/#roles","text":"Requester: Agent who requests the resolution of a DID Resolver: Agent who resolves the given DID (or their own) and returns the result","title":"Roles"},{"location":"guides/interaction_flows/#messages","text":"Resolution Request: The Requester broadcasts a message which may or may not contain a DID. Resolution Result: If the message contains a DID, the Resolver resolves the DID and returns the DID Resolution Result . Otherwise, the Resolver returns the result of resolving it's own DID. This is intended for the special case of \"local\" DID methods, which do not have a globally resolvable state.","title":"Messages"},{"location":"guides/interaction_flows/#examples","text":"A simple Peer Resolution flow between our two Agents from the Identity Management example looks as follows: const aliceResRequest = await alice.createResolutionRequest({ description: 'introduce yourself', callbackURL: 'https://example.com/onboarding', }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceResRequest) const bobsResResponse = await bobsInteraction.createResolutionResponse() // ------- Bob's response is received by Alice ------- // // this adds Bob's identity data (a Key Event Log) to Alice's storage, such that she can now resolve his DID and verify signatures made by him const alicesInteraction = await alice.processJWT(bobsResResponse.encode()) Peer resolution allows for the resolution of Identifiers which rely on a local state proof (e.g. KERI/ did:jun and did:peer ) instead of a globally resolvable state. The successful result of resolving such Identifiers is cached by default by the SDK, and they are resolvable by any Agent instance which shares the same EventDB. Think of such a protocol as an \"introduction\" or \"onboarding\" of a private DID into a backend system. Services which are intended for consumption by natural persons are encouraged to provide at least one method for Agents to resolve themselves using this flow, as these \"local\" Identifiers are designed to solve critical GDPR and User privacy issues affecting DID methods which rely on a global shared state like Blockchains.","title":"Examples"},{"location":"guides/interaction_flows/#authentication","text":"| Proving control over an Identifier. The Authentication flow consists of a simple request-response message exchange, where the contents of the response must match those of the request. Because all Messages are signed and authenticated, the response functions as proof of control by nature of being correctly signed by the keys listed in the DID Document of the issuer. Because of this, in scenarios where a more complex functionality (e.g. Credential Verification) is needed, an additional Authentication flow is not necessary.","title":"Authentication"},{"location":"guides/interaction_flows/#roles_1","text":"Verifier: Agent who requests and verifies the Authenticity of the Authenticator Authenticator: Agent who proves control over their Identifier","title":"Roles"},{"location":"guides/interaction_flows/#messages_1","text":"Authentication Request: The Verifier broadcasts containing only an optional description of the purpose of the authentication. Authentication Response: Contains the same content as the Request.","title":"Messages"},{"location":"guides/interaction_flows/#examples_1","text":"A simple Authentication flow between our two Agents looks as follows: const authRequest = await alice.authRequest({ callbackURL: 'https://example.com/auth', description: 'are you bob?', }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(authRequest) const bobsAuthResponse = await bobsInteraction.createAuthenticationResponse() // ------- Bob's response is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsAuthResponse.encode())","title":"Examples"},{"location":"guides/interaction_flows/#authorization","text":"| Giving consent or permission. The Authorization flow consists of a simple request-response message exchange, where the Initiator requests authorization from the Authorizer to carry out some action. It is similar to the Authentication flow in structure, however the intent of the interaction is different, and it will render differently in the Jolocom Smartwallet. Authentication is about proving the Identity of an agent (e.g. SSO), while Authorization is about giving permission or privilege for a service to act on an agents behalf.","title":"Authorization"},{"location":"guides/interaction_flows/#roles_2","text":"Authorized: Agent requesting Authorization to perform some action Authorizer: Agent granting Authorization to the Authorized","title":"Roles"},{"location":"guides/interaction_flows/#messages_2","text":"Authorization Request: The Authorized broadcasts a message representing the intent of the action which permission is required for. Authorization Response: The Authorizer responds with a message containing the same contents as the Request as consent.","title":"Messages"},{"location":"guides/interaction_flows/#examples_2","text":"A simple Authorization flow between our two Agents from before looks as follows: const aliceAuthZRequest = await alice.authorizationRequestToken({ description: 'Front Door', imageURL: 'https://example.com/lockImage.png', action: 'Open the door', callbackURL: 'https://example.com/authz/', }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceAuthZRequest) const bobsAuthZResponse = await bobsInteraction.createAuthorizationResponse() // ------- Bob's response is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsAuthZResponse.encode())","title":"Examples"},{"location":"guides/interaction_flows/#verifiable-credential-issuance","text":"| Creating an authenticated statement about an Identifier. The Issuance flow consists of a three step message exchange between two parties, the Issuer and the Holder.","title":"Verifiable Credential Issuance"},{"location":"guides/interaction_flows/#roles_3","text":"Issuer: Agent who offers and issues one or more Verifiable Credentials Holder: Agent who selects and receives one or more Verifiable Credentials","title":"Roles"},{"location":"guides/interaction_flows/#messages_3","text":"Credential Offer: The Issuer broadcasts a message containing a list of credential types offered for issuance in this interaction, each with it's own list of requirements which must be satisfied by the Holder in order to qualify for the credential. Credential Selection: The Holder responds with a message containing a list of selected credentials with associated data for satisfying requirements. Credential Issuance: The Issuer responds with a message containing a list of newly issued credentials corrosponding to the selected set.","title":"Messages"},{"location":"guides/interaction_flows/#examples_3","text":"In this simple example, Alice is issuing Bob the Credential she created for him in the Verifiable Credentials section: const aliceCredOffer = await alice.credentialOffer({ callbackURL: 'https://example.com/issuance', offeredCredentials: [ { type: 'SimpleExampleCredential', }, ], }) // ------- the offer is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceCredOffer) const bobsCredSelection = await bobsInteraction.createCredentialOfferResponseToken( [{ type: 'SimpleExampleCredential' }], ) // ------- Bob's selection is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsCredSelection.encode()) const alicesIssuance = await alicesInteraction.createCredentialReceiveToken( alicesCredAboutBob, ) // ------- Bob Receives and stores the newly issued Credential ------- // // Note that storage of the credential is handled automatically by the SDK const bobReceives = await bob.processJWT(alicesIssuence.encode())","title":"Examples"},{"location":"guides/interaction_flows/#credential-verification","text":"| Proving a set of statements about an Identifier. The Credential Verification flow is a simple request-response message exchange between the Verifier and the Prover.","title":"Credential Verification"},{"location":"guides/interaction_flows/#roles_4","text":"Verifier: Agent who requests a set of Verifiable Credentials with associated requirements. Prover: Agent who provides a set of Verifiable Credentials attempting to satisfy the request","title":"Roles"},{"location":"guides/interaction_flows/#messages_4","text":"Credential Request: The Verifier broadcasts a message containing a list of credential types, each with it's own list of requirements to be satisfied by the Prover. Credential Response: The Prover responds with a list of credentials which should satisfy the corrosponding requirements in the Credential Request.","title":"Messages"},{"location":"guides/interaction_flows/#examples_4","text":"In this example, Alice is requesting from Bob the same type of Credential she issued for him in the Credential Issuance section: const aliceCredRequest = await alice.credentialRequestToken({ callbackURL: 'https://example.com/request', credentialRequirements: [ { type: ['SimpleExampleCredential'], constraints: [greater('age', 18), is('name', 'Bob')], }, ], }) // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(aliceAuthZRequest) const bobsAuthZResponse = await bobsInteraction.createCredentialResponse([ alicesCredAboutBob.id, // use the ID from the aliceCredAboutBob instance ]) // ------- Bob's response is received by Alice ------- // const alicesInteraction = await alice.processJWT(bobsAuthZResponse.encode()) Note that the response argument is a list of Credential IDs. Each Credential has an ID which is a hash of the credential. The response creation will fetch each credential referenced in the list from the Agent Storage and include them in the response.","title":"Examples"},{"location":"guides/sdk_install_conf/","text":"Installation and configuration The following sections will briefly describe how to add the Jolocom SDK to your project, as well as briefly outline some of the exposed configuration options (e.g. how to add / remove / switch between DID methods). Installing the Jolocom SDK In order to be able to install and run the Jolocom SDK, Node.js v10 is required. Depending on your package manager, you can simply run: npm i @jolocom/sdk jolocom-lib # In case you use yarn yarn add @jolocom/sdk jolocom-lib In case you would like to avoid implementing a custom storage backend for the SDK, the @jolocom/sdk-storage-typeorm module should be installed at this point as well. Instantiating the Jolocom SDK The Jolocom SDK relies on an injected storage module / backend to persist data (e.g. DID Documents, Verifiable Credentials, Encrypted keys) required / collected as part of various SSI interactions. Custom storage backend implementations can be defined, as long as they satisfy the IStorage interface. The fastest way to get a compliant storage module is by using the @jolocom/sdk-storage-typeorm module: import { JolocomSDK, NaivePasswordStore } from '@jolocom/sdk' import { JolocomTypeormStorage } from '@jolocom/sdk-storage-typeorm' import { createConnection } from 'typeorm' const typeOrmConfig = { name: 'demoDb', type: 'sqlite', database: ':memory:', dropSchema: true, entities: ['node_modules/@jolocom/sdk-storage-typeorm/js/src/entities/*.js'], synchronize: true, logging: false, } const connection = await createConnection(typeOrmConfig) const sdk = new JolocomSDK({ storage: new JolocomTypeormStorage(connection), }) An additional optional argument, eventDB , can be provided to the constructor to specify a custom storage backend for \"events\" encountered as part of Peer-Resolution flows . This DB will only be used for particular DID methods. In case no argument is passed, the storage argument is used instead.","title":"Installation and configuration"},{"location":"guides/sdk_install_conf/#installation-and-configuration","text":"The following sections will briefly describe how to add the Jolocom SDK to your project, as well as briefly outline some of the exposed configuration options (e.g. how to add / remove / switch between DID methods).","title":"Installation and configuration"},{"location":"guides/sdk_install_conf/#installing-the-jolocom-sdk","text":"In order to be able to install and run the Jolocom SDK, Node.js v10 is required. Depending on your package manager, you can simply run: npm i @jolocom/sdk jolocom-lib # In case you use yarn yarn add @jolocom/sdk jolocom-lib In case you would like to avoid implementing a custom storage backend for the SDK, the @jolocom/sdk-storage-typeorm module should be installed at this point as well.","title":"Installing the Jolocom SDK"},{"location":"guides/sdk_install_conf/#instantiating-the-jolocom-sdk","text":"The Jolocom SDK relies on an injected storage module / backend to persist data (e.g. DID Documents, Verifiable Credentials, Encrypted keys) required / collected as part of various SSI interactions. Custom storage backend implementations can be defined, as long as they satisfy the IStorage interface. The fastest way to get a compliant storage module is by using the @jolocom/sdk-storage-typeorm module: import { JolocomSDK, NaivePasswordStore } from '@jolocom/sdk' import { JolocomTypeormStorage } from '@jolocom/sdk-storage-typeorm' import { createConnection } from 'typeorm' const typeOrmConfig = { name: 'demoDb', type: 'sqlite', database: ':memory:', dropSchema: true, entities: ['node_modules/@jolocom/sdk-storage-typeorm/js/src/entities/*.js'], synchronize: true, logging: false, } const connection = await createConnection(typeOrmConfig) const sdk = new JolocomSDK({ storage: new JolocomTypeormStorage(connection), }) An additional optional argument, eventDB , can be provided to the constructor to specify a custom storage backend for \"events\" encountered as part of Peer-Resolution flows . This DB will only be used for particular DID methods. In case no argument is passed, the storage argument is used instead.","title":"Instantiating the Jolocom SDK"},{"location":"visuals/codeflower/","text":"CodeFlower This experiment visualizes source repositories using an interactive tree. Each disc represents a file, with a radius proportional to the number of lines of code (loc). All rendering is done client-side, in JavaScript. Built with d3.js , inspired by Code Swarm and Gource , published with the MIT open-source license. Interact with CodeFlowers, see examples, and build your own at http://fzaninotto.github.com/CodeFlower . You might also like DependencyWheel , another d3.js visualization for indirect dependencies in software packages.","title":"Index"},{"location":"visuals/codeflower/#codeflower","text":"This experiment visualizes source repositories using an interactive tree. Each disc represents a file, with a radius proportional to the number of lines of code (loc). All rendering is done client-side, in JavaScript. Built with d3.js , inspired by Code Swarm and Gource , published with the MIT open-source license. Interact with CodeFlowers, see examples, and build your own at http://fzaninotto.github.com/CodeFlower . You might also like DependencyWheel , another d3.js visualization for indirect dependencies in software packages.","title":"CodeFlower"},{"location":"visuals/depwheel/","text":"Dependency Wheel This experiment visualizes package dependencies using an interactive disc. Each disc section represents a dependency, and links between arcs materialize these dependencies. All rendering is done client-side, in JavaScript. Built with d3.js , published with the MIT open-source license. Interact with DependencyWheels, see examples, and build your own at http://fzaninotto.github.com/DependencyWheel .","title":"Index"},{"location":"visuals/depwheel/#dependency-wheel","text":"This experiment visualizes package dependencies using an interactive disc. Each disc section represents a dependency, and links between arcs materialize these dependencies. All rendering is done client-side, in JavaScript. Built with d3.js , published with the MIT open-source license. Interact with DependencyWheels, see examples, and build your own at http://fzaninotto.github.com/DependencyWheel .","title":"Dependency Wheel"}]}