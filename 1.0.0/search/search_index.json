{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Jolocom Software Development Kit - Facilitating applications to manage and interact with digital identities. The Jolocom SDK is a toolkit for managing SSI Agents and the interactions carried out between them, allowing services and clients to work together seamlessly with minimal trust assumptions and maximum security. For optimal utility and interoperability, the SDK builds upon implementations of the following specifications: W3C Decentralized Identifiers (DIDs) : To provide identifiers for Agents managed by the SDK. W3C Verifiable Credentials (VCs) : To allow for verifiable attestations to be exchanged and utilised by Agents. The SDK is composed of a few core concepts which work together to provide a framework for making use of Decentralized Identities, and provides an interface to the SSI ecosystem via Agents and Interactions. It is designed to streamline the creation, validation, authentication and processing of signed messages in order to facilitate different protocols enacted between Agents. Messages created by Agents are secured by the security mechanism of their chosen DID Method . The SDK itself functions as an Agent Factory. It manages a storage connection and a collection of registered DID Methods, providing storage access and resolution capabilities to the Agents which it creates. This documentation contains information on how to: Install, configure and instantiate the Jolocom SDK Use an instance of the Jolocom SDK to create Agents Use the created Agents to Participate in various SSI interactions Create Verifiable Credentials For API documentation, see the API docs .","title":"Introduction"},{"location":"#introduction","text":"Jolocom Software Development Kit - Facilitating applications to manage and interact with digital identities. The Jolocom SDK is a toolkit for managing SSI Agents and the interactions carried out between them, allowing services and clients to work together seamlessly with minimal trust assumptions and maximum security. For optimal utility and interoperability, the SDK builds upon implementations of the following specifications: W3C Decentralized Identifiers (DIDs) : To provide identifiers for Agents managed by the SDK. W3C Verifiable Credentials (VCs) : To allow for verifiable attestations to be exchanged and utilised by Agents. The SDK is composed of a few core concepts which work together to provide a framework for making use of Decentralized Identities, and provides an interface to the SSI ecosystem via Agents and Interactions. It is designed to streamline the creation, validation, authentication and processing of signed messages in order to facilitate different protocols enacted between Agents. Messages created by Agents are secured by the security mechanism of their chosen DID Method . The SDK itself functions as an Agent Factory. It manages a storage connection and a collection of registered DID Methods, providing storage access and resolution capabilities to the Agents which it creates. This documentation contains information on how to: Install, configure and instantiate the Jolocom SDK Use an instance of the Jolocom SDK to create Agents Use the created Agents to Participate in various SSI interactions Create Verifiable Credentials For API documentation, see the API docs .","title":"Introduction"},{"location":"guides/agents/","text":"Agents An Agent represents an Identity capable of interacting with other Agents. It is the core of any service or application built with the SDK. Agents are suitable for all roles in any SSI interaction, and can be used for client-server or P2P style services. To create/load an Agent, a JolocomSDK instance is needed, refer to the Configuration section for details. Agent Identity Each Agent possesses an Identity (representing DID Document), that must be created or loaded from storage to initialize the Agent. Refer to the Identity section for more details. Agent Interactions Agents interact together by engaging in Interaction Flows . Each interaction flow defines a set of signed messages to be exchanged in a certain order between 2 or more Agents. The messages are signed and verified using the keys associated with each Agent's DID Document. Common Interactions Flows are: Authentication Authorization Verifiable Credential Creation Issuance and Receipt of Verifiable Credentials Requesting, Providing and Verifying of Verifiable Credentials Examples Below, we see an example setup of two Agents which will be used for examples in this documentation. These Agent instances can run within the same Node process, however for this case they can be imagined to be running on a client-server model, where Alice is the server and Bob is the client. Alices Agent loading: // The Alice Agent (did:jolo:alice) is loaded from the sdk storage const alice = await sdk.loadIdentity('alicesPassword', 'did:jolo:alice') Bob Agent creation: // The Bob Agent is randomly generated using the 'jun' DID method const bob = await sdk.createNewAgent('bobsPassword', 'jun') Now that our Agents are instantiated, let's see how they can be used to set up Interaction Flows .","title":"Agents"},{"location":"guides/agents/#agents","text":"An Agent represents an Identity capable of interacting with other Agents. It is the core of any service or application built with the SDK. Agents are suitable for all roles in any SSI interaction, and can be used for client-server or P2P style services. To create/load an Agent, a JolocomSDK instance is needed, refer to the Configuration section for details.","title":"Agents"},{"location":"guides/agents/#agent-identity","text":"Each Agent possesses an Identity (representing DID Document), that must be created or loaded from storage to initialize the Agent. Refer to the Identity section for more details.","title":"Agent Identity"},{"location":"guides/agents/#agent-interactions","text":"Agents interact together by engaging in Interaction Flows . Each interaction flow defines a set of signed messages to be exchanged in a certain order between 2 or more Agents. The messages are signed and verified using the keys associated with each Agent's DID Document. Common Interactions Flows are: Authentication Authorization Verifiable Credential Creation Issuance and Receipt of Verifiable Credentials Requesting, Providing and Verifying of Verifiable Credentials","title":"Agent Interactions"},{"location":"guides/agents/#examples","text":"Below, we see an example setup of two Agents which will be used for examples in this documentation. These Agent instances can run within the same Node process, however for this case they can be imagined to be running on a client-server model, where Alice is the server and Bob is the client. Alices Agent loading: // The Alice Agent (did:jolo:alice) is loaded from the sdk storage const alice = await sdk.loadIdentity('alicesPassword', 'did:jolo:alice') Bob Agent creation: // The Bob Agent is randomly generated using the 'jun' DID method const bob = await sdk.createNewAgent('bobsPassword', 'jun') Now that our Agents are instantiated, let's see how they can be used to set up Interaction Flows .","title":"Examples"},{"location":"guides/channels/","text":"Channels Channels are authenticated long running connections established between two Agents. Once established, a channel can be used to start one or more Interactions To establish a channel, two agents must first go through an EstablishChannelFlow successfully. This consists of a request and a response. Request The request consists of a description (purpose) of the channel, and a list of possible transports to use for the channel. One agent, alice, prepares this request and sends it to another agent, bob. // after creating an agent, alice (refer to introduction) import { ChannelTransportType } from '@jolocom/sdk' const establishChToken = await alice.establishChannelRequestToken({ description: 'test channel', transports: [ { type: ChannelTransportType.WebSockets, config: 'ws://localhost:9000', }, ], }) Currently only one transport type, WebSockets, is supported for creating channels, but this can be extended by defining new transports, as long as both agents are configured to support them. The initial establish channel request must be propagated to the counterparty in some application-specific manner (QR code, backend request, etc). Currently, the application is also expected to externally create a websocket server and generate the correct URL (passed in config ) in the channel establishment request. An example of how to do this can be found at https://github.com/jolocom/web-service-base Response The response is simply a selection of which transport will be used. The response token is created then sent over the channel as soon as the transport is open. So on bob's end: // bob receives the token (app specific), processes it to get a new interaction const bobInterxn = bob.processJWT(establishChToken.encode()) // inspect the transport options import { EstablishChannelFlowState } from '@jolocom/sdk/js/interactionManager/types' const flowState = bobInterxn.getSummary().state as EstablishChannelFlowState console.log(flowState.transports) // create a response selecting the transport at index 0 const establishResp = await bobInterxn.createEstablishChannelResponse(0) // process the response locally to update our own interaction state await bobInterxn.processInteractionToken(establishResp.encode()) Now bob's interaction state is up to date, and they must open the channel. Note that the WebSocket transport needs to be configured prior to use, please refer to the configuration guide // create a channel based on this interaction const bobCh = await sdk.channels.create(bobInterxn) // \"start\" the channel, by giving it an interaction callback, to be called // when new interactions get created from a request coming in on the channel await bobCh.start(async interxn => { // do something with the incoming interaction // then use interxn.send interxn.send(responseToken) }) // once start returns (async), the transport is active, and the first message Finally, now that the transport is open, bob needs to send the channel establishment response to alice, as the first message on this (unauthenticated) channel. // sent should be the response to the establish channel request await bobCh.send(establishResp) Once alice receives this message and validates it, the channel is considered established. Using the Channel Now that the channel is established, further interactions can happen on it using the startThread method: const authRequest = await alice.authRequest({ callbackURL: '', // can be left empty because // we will use the pre-established channel description: 'are you bob?', }) const response = await ch.startThread(authRequest) // 'response' is the token that was received as a response // it has already been processed, no need to process it","title":"Channels"},{"location":"guides/channels/#channels","text":"Channels are authenticated long running connections established between two Agents. Once established, a channel can be used to start one or more Interactions To establish a channel, two agents must first go through an EstablishChannelFlow successfully. This consists of a request and a response.","title":"Channels"},{"location":"guides/channels/#request","text":"The request consists of a description (purpose) of the channel, and a list of possible transports to use for the channel. One agent, alice, prepares this request and sends it to another agent, bob. // after creating an agent, alice (refer to introduction) import { ChannelTransportType } from '@jolocom/sdk' const establishChToken = await alice.establishChannelRequestToken({ description: 'test channel', transports: [ { type: ChannelTransportType.WebSockets, config: 'ws://localhost:9000', }, ], }) Currently only one transport type, WebSockets, is supported for creating channels, but this can be extended by defining new transports, as long as both agents are configured to support them. The initial establish channel request must be propagated to the counterparty in some application-specific manner (QR code, backend request, etc). Currently, the application is also expected to externally create a websocket server and generate the correct URL (passed in config ) in the channel establishment request. An example of how to do this can be found at https://github.com/jolocom/web-service-base","title":"Request"},{"location":"guides/channels/#response","text":"The response is simply a selection of which transport will be used. The response token is created then sent over the channel as soon as the transport is open. So on bob's end: // bob receives the token (app specific), processes it to get a new interaction const bobInterxn = bob.processJWT(establishChToken.encode()) // inspect the transport options import { EstablishChannelFlowState } from '@jolocom/sdk/js/interactionManager/types' const flowState = bobInterxn.getSummary().state as EstablishChannelFlowState console.log(flowState.transports) // create a response selecting the transport at index 0 const establishResp = await bobInterxn.createEstablishChannelResponse(0) // process the response locally to update our own interaction state await bobInterxn.processInteractionToken(establishResp.encode()) Now bob's interaction state is up to date, and they must open the channel. Note that the WebSocket transport needs to be configured prior to use, please refer to the configuration guide // create a channel based on this interaction const bobCh = await sdk.channels.create(bobInterxn) // \"start\" the channel, by giving it an interaction callback, to be called // when new interactions get created from a request coming in on the channel await bobCh.start(async interxn => { // do something with the incoming interaction // then use interxn.send interxn.send(responseToken) }) // once start returns (async), the transport is active, and the first message Finally, now that the transport is open, bob needs to send the channel establishment response to alice, as the first message on this (unauthenticated) channel. // sent should be the response to the establish channel request await bobCh.send(establishResp) Once alice receives this message and validates it, the channel is considered established.","title":"Response"},{"location":"guides/channels/#using-the-channel","text":"Now that the channel is established, further interactions can happen on it using the startThread method: const authRequest = await alice.authRequest({ callbackURL: '', // can be left empty because // we will use the pre-established channel description: 'are you bob?', }) const response = await ch.startThread(authRequest) // 'response' is the token that was received as a response // it has already been processed, no need to process it","title":"Using the Channel"},{"location":"guides/credentials/","text":"Verifiable Credentials Verifiable Credentials represent information that one Identifier is asserting to be true about another Identifier. These statements are authenticated by verifying the signatures made on them by the issuer. Credentials can be created by Agents. Because they have a structured semantic meaning, each Verifiable Credential type must be defined in terms of a context. This is important, else the term will not appear in the signed data and will not be secured by the proof. This context is a mapping of terms found in the Credential to URIs which represent the meaning of the term. An example Credential creation is as follows, note that the simpleExampleCredMetadata constitutes the definition of the Credential type and should be re-used: const simpleExampleCredMetadata = { type: ['Credential', 'SimpleExampleCredential'], name: 'Example Name and Age', context: [ { SimpleExample: 'https://example.com/terms/SimpleExampleCredential', schema: 'https://schema.org/', age: 'schema:age', name: 'schema:name', }, ], } const alicesCredAboutBob = await alice.signedCredential({ metadata: simpleExampleCredMetadata, subject: bobsDID, claim: { age: 25, name: 'Bob', }, }) In this simple example, one of our Agents (Alice) is creates a credential with Bob as the subject, stating that his age is 25 and that his name is Bob. For details on how to actually transfer this credential from Alice to Bob (Issuance) or make use of the credential (Verification), see the Credential Issuance and Credential Verification sections. For detailed documentation on defining Verifiable Credential types, see the Credentials section of the Jolocom Library documentation.","title":"Verifiable Credentials"},{"location":"guides/credentials/#verifiable-credentials","text":"Verifiable Credentials represent information that one Identifier is asserting to be true about another Identifier. These statements are authenticated by verifying the signatures made on them by the issuer. Credentials can be created by Agents. Because they have a structured semantic meaning, each Verifiable Credential type must be defined in terms of a context. This is important, else the term will not appear in the signed data and will not be secured by the proof. This context is a mapping of terms found in the Credential to URIs which represent the meaning of the term. An example Credential creation is as follows, note that the simpleExampleCredMetadata constitutes the definition of the Credential type and should be re-used: const simpleExampleCredMetadata = { type: ['Credential', 'SimpleExampleCredential'], name: 'Example Name and Age', context: [ { SimpleExample: 'https://example.com/terms/SimpleExampleCredential', schema: 'https://schema.org/', age: 'schema:age', name: 'schema:name', }, ], } const alicesCredAboutBob = await alice.signedCredential({ metadata: simpleExampleCredMetadata, subject: bobsDID, claim: { age: 25, name: 'Bob', }, }) In this simple example, one of our Agents (Alice) is creates a credential with Bob as the subject, stating that his age is 25 and that his name is Bob. For details on how to actually transfer this credential from Alice to Bob (Issuance) or make use of the credential (Verification), see the Credential Issuance and Credential Verification sections. For detailed documentation on defining Verifiable Credential types, see the Credentials section of the Jolocom Library documentation.","title":"Verifiable Credentials"},{"location":"guides/dev_test_formatting/","text":"Development Clone the sdk repository to your computer. cd into the directory and run yarn or yarn install from your terminal to install the required packages. To run a repl, use yarn repl . Testing We use Jest for unit tests. To run unit tests, with watch and testing coverage display enabled: yarn test --watch --coverage Code Style and Formatting We use ESLint and Prettier to keep a consistent style across the codebase. There are plugins available for a range of IDEs and text editors; automatic formatting on save is also supported in some editors. yarn format will format files automatically as much as possible. Copyright (C) 2014-2020 JOLOCOM GmbH","title":"Dev test formatting"},{"location":"guides/dev_test_formatting/#development","text":"Clone the sdk repository to your computer. cd into the directory and run yarn or yarn install from your terminal to install the required packages. To run a repl, use yarn repl .","title":"Development"},{"location":"guides/dev_test_formatting/#testing","text":"We use Jest for unit tests. To run unit tests, with watch and testing coverage display enabled: yarn test --watch --coverage","title":"Testing"},{"location":"guides/dev_test_formatting/#code-style-and-formatting","text":"We use ESLint and Prettier to keep a consistent style across the codebase. There are plugins available for a range of IDEs and text editors; automatic formatting on save is also supported in some editors. yarn format will format files automatically as much as possible. Copyright (C) 2014-2020 JOLOCOM GmbH","title":"Code Style and Formatting"},{"location":"guides/identity/","text":"Identity Creating an Identity Creating an Agent with a random identity To provision an Agent with a new random identity (i.e. DID and set of keys), the following function can be used: sdk.createAgent('demoPassword', 'jolo') Based on the DID Method the Agent is configured to use, the appropriate identity creation / \"anchoring\" operations are executed (e.g. creating and broadcasting Blockchain transactions, interfacing with various distributed storage backends, etc.). If succesfull, the function returns the DID Document, and the corresponding signing keys, for the newly created identity. The Agent will also persist the created encrypted wallet (containing keys associated with the identity) and DID Document locally (allowing for the identity to be reused at later points), using the storage backend. Two optional arguments can be provided to the createNewAgent function: passwordOrStore - The SDK makes use of a Password Store component, used for persisting secrets (e.g. the symmetric encryption key used to encrypt / decrypt the contents of the user's Wallet). A custom implementation satisfying the IPasswordStore interface can be passed at this point. In case the argument is of type string , a NaivePasswordStore will be instantiated with the provided password. In case no argument is provided, the aforementioned NaivePasswordStore is initiated with a encryption random password. For an example integration with react-native, see the JolocomKeychainPasswordStore . didMethodName - The DID Method used by the Agent. This DID Method will be used when creating an identity for the agent, as well as when recovering an identity from seed material. The Agent will still retain the ability to resolve across all DID Methods supported by the SDK. In case no argument is provided the DID Method registered as default on the SDK instance is used. Create an Agent based on a BIP39 mnemonic In the previous section, the created Agent was provisioned with a newly created DID, as well as a set of signing keys. The only way to reuse an identity created this way is by exporting and later reusing the returned Encrypted Wallet. In case deterministic identity creation is desired, the sdk.createAgentFromMnemonic method can be used as follows: const agent = sdk.createAgentFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) This function allows for the deterministic creation of a DID, and the associated keys. A BIP39 compliant mnemonic is expected as an argument. In case the used registrar does not implement the recoverFromSeed method, an error is thrown. The deterministic derivation of keys from a seed is delegated to the registrar implementation. Internally, BIP32, SLIP0010, or other specifications can be used. The registrar implementation encapsulates the specification, as well as the metadata required for derivation (e.g. paths, indexes, etc.) Based on the DID Method the Agent is configured to use, the appropriate identity creation / \"anchoring\" operations are then executed (e.g. creating and broadcasting Blockchain transactions, interfacing with various distributed storage backends, etc.). If succesfull, the function returns the DID Document, and the corresponding signing keys, for the recovered identity. The Agent will also persist the recovered encrypted wallet (containing the recovered keys) and DID Document locally (allowing for the identity to be reused at later points), using the storage backend. In case the identity is already registered, an error is thrown (in order to prevent accidental identity updates). In case the desired functionality is to register the identity and overwrite any existing entries (as defined by the DID Method) a second boolean argument shouldOverwrite can be set to true . Loading an existing identity As mentioned in the previous sections, using sdk.createAgent or sdk.createAgentFromMnemonic will persist the created / recovered encrypted wallet data using the storage backend the SDK was configured with. To provision the Agent with an identity persisted in the storage backend the following function can be used: sdk.loadAgent('demoPassword', 'did:jolo:aaa...fff') If a DID is provided, the method will attempt to find the associated encrypted wallet / DID Document entries using the storage interface. In case no entries have been found, an error is thrown. In case no argument is provided to the function, the first identity found is used. Note that the password or password store provided should match the password used to previously encrypt the Identity being loaded. Recovering an existing identity from a mnemonic This function is similar to the previously described sdk.createAgentFromMnemonic , except that it does not attempt to register / anchor (as defined by the DID Method) a new identity. Instead, the configured registrar is used to derive the key material, and subsequently the DID, which is resolved using the resolver module. In case the DID is resolvable, and the returned DID Document matches the derived DID / keys, the Agent is provisioned with the recovered identity. In case the identity can not be resolved, an error is thrown. const agent = sdk.loadFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) This method can be used to \"recover\" control over an existing identity, given only the BIP39 mnemonic (i.e. the same one used in a previous createAgentFromMnemonic call). Examples Below, we see an example setup of two Identities which will be used for examples in this documentation. These Agent instances can run within the same Node process, however for this case they can be imagined to be running on a client-server model, where Alice is the server and Bob is the client. For simplicity, imagine that an SDK instance has been created already for each process, as in the Configuration section : Alices Agent loading: // The Alice Agent (did:jolo:alice) is loaded from the SDK storage const alice = await sdk.loadAgent('alicesPassword', 'did:jolo:alice') Bob Agent creation: // The Bob Agent is randomly generated using the 'jun' DID method, and persisted // to storage const bob = await sdk.createAgent('bobsPassword', 'jun') Now that our Agents are instantiated, let's see how they can be used to set up Interaction Flows .","title":"Identity"},{"location":"guides/identity/#identity","text":"","title":"Identity"},{"location":"guides/identity/#creating-an-identity","text":"","title":"Creating an Identity"},{"location":"guides/identity/#creating-an-agent-with-a-random-identity","text":"To provision an Agent with a new random identity (i.e. DID and set of keys), the following function can be used: sdk.createAgent('demoPassword', 'jolo') Based on the DID Method the Agent is configured to use, the appropriate identity creation / \"anchoring\" operations are executed (e.g. creating and broadcasting Blockchain transactions, interfacing with various distributed storage backends, etc.). If succesfull, the function returns the DID Document, and the corresponding signing keys, for the newly created identity. The Agent will also persist the created encrypted wallet (containing keys associated with the identity) and DID Document locally (allowing for the identity to be reused at later points), using the storage backend. Two optional arguments can be provided to the createNewAgent function: passwordOrStore - The SDK makes use of a Password Store component, used for persisting secrets (e.g. the symmetric encryption key used to encrypt / decrypt the contents of the user's Wallet). A custom implementation satisfying the IPasswordStore interface can be passed at this point. In case the argument is of type string , a NaivePasswordStore will be instantiated with the provided password. In case no argument is provided, the aforementioned NaivePasswordStore is initiated with a encryption random password. For an example integration with react-native, see the JolocomKeychainPasswordStore . didMethodName - The DID Method used by the Agent. This DID Method will be used when creating an identity for the agent, as well as when recovering an identity from seed material. The Agent will still retain the ability to resolve across all DID Methods supported by the SDK. In case no argument is provided the DID Method registered as default on the SDK instance is used.","title":"Creating an Agent with a random identity"},{"location":"guides/identity/#create-an-agent-based-on-a-bip39-mnemonic","text":"In the previous section, the created Agent was provisioned with a newly created DID, as well as a set of signing keys. The only way to reuse an identity created this way is by exporting and later reusing the returned Encrypted Wallet. In case deterministic identity creation is desired, the sdk.createAgentFromMnemonic method can be used as follows: const agent = sdk.createAgentFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) This function allows for the deterministic creation of a DID, and the associated keys. A BIP39 compliant mnemonic is expected as an argument. In case the used registrar does not implement the recoverFromSeed method, an error is thrown. The deterministic derivation of keys from a seed is delegated to the registrar implementation. Internally, BIP32, SLIP0010, or other specifications can be used. The registrar implementation encapsulates the specification, as well as the metadata required for derivation (e.g. paths, indexes, etc.) Based on the DID Method the Agent is configured to use, the appropriate identity creation / \"anchoring\" operations are then executed (e.g. creating and broadcasting Blockchain transactions, interfacing with various distributed storage backends, etc.). If succesfull, the function returns the DID Document, and the corresponding signing keys, for the recovered identity. The Agent will also persist the recovered encrypted wallet (containing the recovered keys) and DID Document locally (allowing for the identity to be reused at later points), using the storage backend. In case the identity is already registered, an error is thrown (in order to prevent accidental identity updates). In case the desired functionality is to register the identity and overwrite any existing entries (as defined by the DID Method) a second boolean argument shouldOverwrite can be set to true .","title":"Create an Agent based on a BIP39 mnemonic"},{"location":"guides/identity/#loading-an-existing-identity","text":"As mentioned in the previous sections, using sdk.createAgent or sdk.createAgentFromMnemonic will persist the created / recovered encrypted wallet data using the storage backend the SDK was configured with. To provision the Agent with an identity persisted in the storage backend the following function can be used: sdk.loadAgent('demoPassword', 'did:jolo:aaa...fff') If a DID is provided, the method will attempt to find the associated encrypted wallet / DID Document entries using the storage interface. In case no entries have been found, an error is thrown. In case no argument is provided to the function, the first identity found is used. Note that the password or password store provided should match the password used to previously encrypt the Identity being loaded.","title":"Loading an existing identity"},{"location":"guides/identity/#recovering-an-existing-identity-from-a-mnemonic","text":"This function is similar to the previously described sdk.createAgentFromMnemonic , except that it does not attempt to register / anchor (as defined by the DID Method) a new identity. Instead, the configured registrar is used to derive the key material, and subsequently the DID, which is resolved using the resolver module. In case the DID is resolvable, and the returned DID Document matches the derived DID / keys, the Agent is provisioned with the recovered identity. In case the identity can not be resolved, an error is thrown. const agent = sdk.loadFromMnemonic( 'hammer soul glare stairs indicate snack address divert mosquito chef season hobby', ) This method can be used to \"recover\" control over an existing identity, given only the BIP39 mnemonic (i.e. the same one used in a previous createAgentFromMnemonic call).","title":"Recovering an existing identity from a mnemonic"},{"location":"guides/identity/#examples","text":"Below, we see an example setup of two Identities which will be used for examples in this documentation. These Agent instances can run within the same Node process, however for this case they can be imagined to be running on a client-server model, where Alice is the server and Bob is the client. For simplicity, imagine that an SDK instance has been created already for each process, as in the Configuration section : Alices Agent loading: // The Alice Agent (did:jolo:alice) is loaded from the SDK storage const alice = await sdk.loadAgent('alicesPassword', 'did:jolo:alice') Bob Agent creation: // The Bob Agent is randomly generated using the 'jun' DID method, and persisted // to storage const bob = await sdk.createAgent('bobsPassword', 'jun') Now that our Agents are instantiated, let's see how they can be used to set up Interaction Flows .","title":"Examples"},{"location":"guides/interaction_flows/","text":"Interaction Flows Interaction Flows are the protocols which Agents use to communicate with each other. With them, services can be easily provided and consumed. In practice, they work by using Agents to produce and consume messages, with an Interaction Manager within each Agent handling the validation and storage for each Interaction. Each interaction is defined by: The Roles played by Agents participating in the interaction The set of Message types associated with the type of interaction The set of rules associated with the type of interaction which determine the validity of new messages given the previous messages All Agents participating in an interaction maintain an internal interaction state (generated by applying / processing all messages which make up an interaction). If two Agents process the same set of interaction messages according to the same set of rules (i.e. same protocol / Flow), they will arrive to the same final state. In all further examples, note that Alice and Bob call .processJWT() with their own tokens at various points (e.g. before sending them to the counterparty). This is done to ensure both Agents \"see\" all messages. The interaction messages are not processed automatically by the creator to allow for additional flexibility for updating the interaction state (e.g. the Agent might choose to process a token only after it was sucesfully received by the counterparty, or after some custom validation logic has completed). Authentication Proving control over an Identifier. The Authentication flow consists of a simple request-response message exchange, where the contents of the response must match those of the request. Because all Messages are signed and authenticated, the response functions as proof of control by nature of being correctly signed by the keys listed in the DID Document of the issuer. Because of this, in scenarios where a more complex functionality (e.g. Credential Verification) is needed, an additional Authentication flow is not necessary. Roles Verifier: Agent who requests and verifies the Authenticity of the Authenticator Authenticator: Agent who proves control over their Identifier Messages Authentication Request: The Verifier broadcasts containing only an optional description of the purpose of the authentication. Authentication Response: Contains the same content as the Request. Examples A simple Authentication flow between our two Agents looks as follows: Alice creates an Authentication request: const authRequest = await alice.authRequest({ callbackURL: 'https://example.com/auth', description: 'are you bob?', }) Alices request is broadcast and received and processed by Bob: // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(authRequest.encode()) const bobsAuthResponse = await bobsInteraction.createAuthenticationResponse() await bob.processJWT(bobsAuthResponse.encode()) Bob's response is received and processed by Alice: const alicesInteraction = await alice.processJWT(bobsAuthResponse.encode()) Authorization Giving consent or permission. The Authorization flow consists of a simple request-response message exchange, where the Initiator requests authorization from the Authorizer to carry out some action. It is similar to the Authentication flow in structure, however the intent of the interaction is different, and it will render differently in the Jolocom Smartwallet. Authentication is about proving the Identity of an agent (e.g. SSO), while Authorization is about giving permission or privilege for a service to act on an agents behalf. Roles Authorized: Agent requesting Authorization to perform some action Authorizer: Agent granting Authorization to the Authorized Messages Authorization Request: The Authorized broadcasts a message representing the intent of the action which permission is required for. Authorization Response: The Authorizer responds with a message containing the same contents as the Request as consent. Examples A simple Authorization flow between our two Agents from before looks as follows: Alice creates an Authorization request: const aliceAuthZRequest = await alice.authorizationRequestToken({ description: 'Front Door', imageURL: 'https://example.com/lockImage.png', action: 'Open the door', callbackURL: 'https://example.com/authz/', }) Alices request is broadcast and received and processed by Bob: const bobsInteraction = await bob.processJWT(aliceAuthZRequest.encode()) const bobsAuthZResponse = await bobsInteraction.createAuthorizationResponse() await bob.processJWT(bobsAuthZResponse.encode()) Bob's response is received and processed by Alice: const alicesInteraction = await alice.processJWT(bobsAuthZResponse.encode()) Verifiable Credential Issuance Creating an authenticated statement about an Identifier. The Issuance flow consists of a three step message exchange between two parties, the Issuer and the Holder. Roles Issuer: Agent who offers and issues one or more Verifiable Credentials Holder: Agent who selects and receives one or more Verifiable Credentials Messages Credential Offer: The Issuer broadcasts a message containing a list of credential types offered for issuance in this interaction, each with it's own list of requirements which must be satisfied by the Holder in order to qualify for the credential. Credential Selection: The Holder responds with a message containing a list of selected credentials with associated data for satisfying requirements. Credential Issuance: The Issuer responds with a message containing a list of newly issued credentials corrosponding to the selected set. Examples In this simple example, Alice is issuing Bob the Credential she created for him in the Verifiable Credentials section: Alice creates a Credential Offer: const aliceCredOffer = await alice.credOfferToken({ callbackURL: 'https://example.com/issuance', offeredCredentials: [ { type: 'SimpleExampleCredential', }, ], }) Alices offer is broadcast and received and processed by Bob: const bobsInteraction = await bob.processJWT(aliceCredOffer.encode()) const bobsCredSelection = await bobsInteraction.createCredentialOfferResponseToken( [{ type: 'SimpleExampleCredential' }], ) await bob.processJWT(bobsCredSelection.encode()) Bob's response is received and processed by Alice: const alicesInteraction = await alice.processJWT(bobsCredSelection.encode()) const alicesIssuance = await alicesInteraction.createCredentialReceiveToken( alicesCredAboutBob, ) alice.processJWT(alicesIssuance.encode()) Bob receives Alice's second message, the issuance, and verifies the received Credentials (ensuring the signatures are valid, the issuer is correct, and the received Credentials match the selection encoded in the bobsCredSelection message). Note that the storage of the issued Credentials is not handled automatically (allowing for additional / custom validation logic to be defined / evaluated by the SDK user before storing). const bobReceives = await bob.processJWT(alicesIssuence.encode()) const state = bobRecieving.getSummary().state if (state.credentialsAllValid) { await Promise.all( state.issued.map(VC => bob.storage.store.verifiableCredential(VC)), ) } Credential Verification Proving a set of statements about an Identifier. The Credential Verification flow is a simple request-response message exchange between the Verifier and the Prover. Roles Verifier: Agent who requests a set of Verifiable Credentials with associated requirements. Prover: Agent who provides a set of Verifiable Credentials attempting to satisfy the request Messages Credential Request: The Verifier broadcasts a message containing a list of credential types, each with it's own list of requirements to be satisfied by the Prover. Credential Response: The Prover responds with a list of credentials which should satisfy the corrosponding requirements in the Credential Request. Examples In this example, Alice is requesting from Bob the same type of Credential she issued for him in the Credential Issuance section: Alice creates a Credential Offer: import { JolocomLib } from '@jolocom/sdk' const aliceCredRequest = await alice.credRequestToken({ callbackURL: 'https://example.com/request', credentialRequirements: [ { type: ['SimpleExampleCredential'], constraints: [ JolocomLib.util.constraintFunctions.greater('age', 18), JolocomLib.util.constraintFunctions.is('name', 'Bob'), ], }, ], }) Alices request is broadcast and received and processed by Bob: const bobsInteraction = await bob.processJWT(aliceCredRequest.encode()) const bobsCredResponse = await bobsInteraction.createCredentialResponse([ alicesCredAboutBob.id, // use the ID from the aliceCredAboutBob instance ]) await bob.processJWT(bobsCredResponse.encode()) Bob's response is received and verified by Alice: const alicesInteraction = await alice.processJWT(bobsCredResponse.encode()) Note that the response argument is a list of Credential IDs. Each Credential has an ID which is a hash of the credential. The response creation will fetch each credential referenced in the list from the Agent Storage and include them in the response. Peer Resolution Using another Agent as a Resolver Peer resolution consists of a simple request-response message exchange, where the Requester asks the Resolver to perform DID resolution and return the result. Roles Requester: Agent who requests the resolution of a DID Resolver: Agent who resolves the given DID (or their own) and returns the result Messages Resolution Request: The Requester broadcasts a message which may or may not contain a DID. Resolution Result: If the message contains a DID, the Resolver resolves the DID and returns the DID Resolution Result . Otherwise, the Resolver returns the result of resolving it's own DID. This is intended for the special case of \"local\" DID methods, which do not have a globally resolvable state. Examples A simple Peer Resolution flow between our two Agents from the Identity Management example looks as follows: Alice creates a resolution request: const aliceResRequest = await alice.createResolutionRequest({ description: 'introduce yourself', callbackURL: 'https://example.com/onboarding', }) Alices request is received by Bob (by some means, e.g. QR code) and processed: const bobsInteraction = await bob.processJWT(aliceResRequest) const bobsResResponse = await bobsInteraction.createResolutionResponse() await bob.processJWT(bobsResResponse.encode()) Bob's response is received by Alice (e.g. via POSTing to the callbackURL ): // this adds Bob's identity data (a Key Event Log) to Alice's storage, such that she can now resolve his DID and verify signatures made by him const alicesInteraction = await alice.processJWT(bobsResResponse.encode())","title":"Interaction Flows"},{"location":"guides/interaction_flows/#interaction-flows","text":"Interaction Flows are the protocols which Agents use to communicate with each other. With them, services can be easily provided and consumed. In practice, they work by using Agents to produce and consume messages, with an Interaction Manager within each Agent handling the validation and storage for each Interaction. Each interaction is defined by: The Roles played by Agents participating in the interaction The set of Message types associated with the type of interaction The set of rules associated with the type of interaction which determine the validity of new messages given the previous messages All Agents participating in an interaction maintain an internal interaction state (generated by applying / processing all messages which make up an interaction). If two Agents process the same set of interaction messages according to the same set of rules (i.e. same protocol / Flow), they will arrive to the same final state. In all further examples, note that Alice and Bob call .processJWT() with their own tokens at various points (e.g. before sending them to the counterparty). This is done to ensure both Agents \"see\" all messages. The interaction messages are not processed automatically by the creator to allow for additional flexibility for updating the interaction state (e.g. the Agent might choose to process a token only after it was sucesfully received by the counterparty, or after some custom validation logic has completed).","title":"Interaction Flows"},{"location":"guides/interaction_flows/#authentication","text":"Proving control over an Identifier. The Authentication flow consists of a simple request-response message exchange, where the contents of the response must match those of the request. Because all Messages are signed and authenticated, the response functions as proof of control by nature of being correctly signed by the keys listed in the DID Document of the issuer. Because of this, in scenarios where a more complex functionality (e.g. Credential Verification) is needed, an additional Authentication flow is not necessary.","title":"Authentication"},{"location":"guides/interaction_flows/#roles","text":"Verifier: Agent who requests and verifies the Authenticity of the Authenticator Authenticator: Agent who proves control over their Identifier","title":"Roles"},{"location":"guides/interaction_flows/#messages","text":"Authentication Request: The Verifier broadcasts containing only an optional description of the purpose of the authentication. Authentication Response: Contains the same content as the Request.","title":"Messages"},{"location":"guides/interaction_flows/#examples","text":"A simple Authentication flow between our two Agents looks as follows: Alice creates an Authentication request: const authRequest = await alice.authRequest({ callbackURL: 'https://example.com/auth', description: 'are you bob?', }) Alices request is broadcast and received and processed by Bob: // ------- the request is received by Bob ------- // const bobsInteraction = await bob.processJWT(authRequest.encode()) const bobsAuthResponse = await bobsInteraction.createAuthenticationResponse() await bob.processJWT(bobsAuthResponse.encode()) Bob's response is received and processed by Alice: const alicesInteraction = await alice.processJWT(bobsAuthResponse.encode())","title":"Examples"},{"location":"guides/interaction_flows/#authorization","text":"Giving consent or permission. The Authorization flow consists of a simple request-response message exchange, where the Initiator requests authorization from the Authorizer to carry out some action. It is similar to the Authentication flow in structure, however the intent of the interaction is different, and it will render differently in the Jolocom Smartwallet. Authentication is about proving the Identity of an agent (e.g. SSO), while Authorization is about giving permission or privilege for a service to act on an agents behalf.","title":"Authorization"},{"location":"guides/interaction_flows/#roles_1","text":"Authorized: Agent requesting Authorization to perform some action Authorizer: Agent granting Authorization to the Authorized","title":"Roles"},{"location":"guides/interaction_flows/#messages_1","text":"Authorization Request: The Authorized broadcasts a message representing the intent of the action which permission is required for. Authorization Response: The Authorizer responds with a message containing the same contents as the Request as consent.","title":"Messages"},{"location":"guides/interaction_flows/#examples_1","text":"A simple Authorization flow between our two Agents from before looks as follows: Alice creates an Authorization request: const aliceAuthZRequest = await alice.authorizationRequestToken({ description: 'Front Door', imageURL: 'https://example.com/lockImage.png', action: 'Open the door', callbackURL: 'https://example.com/authz/', }) Alices request is broadcast and received and processed by Bob: const bobsInteraction = await bob.processJWT(aliceAuthZRequest.encode()) const bobsAuthZResponse = await bobsInteraction.createAuthorizationResponse() await bob.processJWT(bobsAuthZResponse.encode()) Bob's response is received and processed by Alice: const alicesInteraction = await alice.processJWT(bobsAuthZResponse.encode())","title":"Examples"},{"location":"guides/interaction_flows/#verifiable-credential-issuance","text":"Creating an authenticated statement about an Identifier. The Issuance flow consists of a three step message exchange between two parties, the Issuer and the Holder.","title":"Verifiable Credential Issuance"},{"location":"guides/interaction_flows/#roles_2","text":"Issuer: Agent who offers and issues one or more Verifiable Credentials Holder: Agent who selects and receives one or more Verifiable Credentials","title":"Roles"},{"location":"guides/interaction_flows/#messages_2","text":"Credential Offer: The Issuer broadcasts a message containing a list of credential types offered for issuance in this interaction, each with it's own list of requirements which must be satisfied by the Holder in order to qualify for the credential. Credential Selection: The Holder responds with a message containing a list of selected credentials with associated data for satisfying requirements. Credential Issuance: The Issuer responds with a message containing a list of newly issued credentials corrosponding to the selected set.","title":"Messages"},{"location":"guides/interaction_flows/#examples_2","text":"In this simple example, Alice is issuing Bob the Credential she created for him in the Verifiable Credentials section: Alice creates a Credential Offer: const aliceCredOffer = await alice.credOfferToken({ callbackURL: 'https://example.com/issuance', offeredCredentials: [ { type: 'SimpleExampleCredential', }, ], }) Alices offer is broadcast and received and processed by Bob: const bobsInteraction = await bob.processJWT(aliceCredOffer.encode()) const bobsCredSelection = await bobsInteraction.createCredentialOfferResponseToken( [{ type: 'SimpleExampleCredential' }], ) await bob.processJWT(bobsCredSelection.encode()) Bob's response is received and processed by Alice: const alicesInteraction = await alice.processJWT(bobsCredSelection.encode()) const alicesIssuance = await alicesInteraction.createCredentialReceiveToken( alicesCredAboutBob, ) alice.processJWT(alicesIssuance.encode()) Bob receives Alice's second message, the issuance, and verifies the received Credentials (ensuring the signatures are valid, the issuer is correct, and the received Credentials match the selection encoded in the bobsCredSelection message). Note that the storage of the issued Credentials is not handled automatically (allowing for additional / custom validation logic to be defined / evaluated by the SDK user before storing). const bobReceives = await bob.processJWT(alicesIssuence.encode()) const state = bobRecieving.getSummary().state if (state.credentialsAllValid) { await Promise.all( state.issued.map(VC => bob.storage.store.verifiableCredential(VC)), ) }","title":"Examples"},{"location":"guides/interaction_flows/#credential-verification","text":"Proving a set of statements about an Identifier. The Credential Verification flow is a simple request-response message exchange between the Verifier and the Prover.","title":"Credential Verification"},{"location":"guides/interaction_flows/#roles_3","text":"Verifier: Agent who requests a set of Verifiable Credentials with associated requirements. Prover: Agent who provides a set of Verifiable Credentials attempting to satisfy the request","title":"Roles"},{"location":"guides/interaction_flows/#messages_3","text":"Credential Request: The Verifier broadcasts a message containing a list of credential types, each with it's own list of requirements to be satisfied by the Prover. Credential Response: The Prover responds with a list of credentials which should satisfy the corrosponding requirements in the Credential Request.","title":"Messages"},{"location":"guides/interaction_flows/#examples_3","text":"In this example, Alice is requesting from Bob the same type of Credential she issued for him in the Credential Issuance section: Alice creates a Credential Offer: import { JolocomLib } from '@jolocom/sdk' const aliceCredRequest = await alice.credRequestToken({ callbackURL: 'https://example.com/request', credentialRequirements: [ { type: ['SimpleExampleCredential'], constraints: [ JolocomLib.util.constraintFunctions.greater('age', 18), JolocomLib.util.constraintFunctions.is('name', 'Bob'), ], }, ], }) Alices request is broadcast and received and processed by Bob: const bobsInteraction = await bob.processJWT(aliceCredRequest.encode()) const bobsCredResponse = await bobsInteraction.createCredentialResponse([ alicesCredAboutBob.id, // use the ID from the aliceCredAboutBob instance ]) await bob.processJWT(bobsCredResponse.encode()) Bob's response is received and verified by Alice: const alicesInteraction = await alice.processJWT(bobsCredResponse.encode()) Note that the response argument is a list of Credential IDs. Each Credential has an ID which is a hash of the credential. The response creation will fetch each credential referenced in the list from the Agent Storage and include them in the response.","title":"Examples"},{"location":"guides/interaction_flows/#peer-resolution","text":"Using another Agent as a Resolver Peer resolution consists of a simple request-response message exchange, where the Requester asks the Resolver to perform DID resolution and return the result.","title":"Peer Resolution"},{"location":"guides/interaction_flows/#roles_4","text":"Requester: Agent who requests the resolution of a DID Resolver: Agent who resolves the given DID (or their own) and returns the result","title":"Roles"},{"location":"guides/interaction_flows/#messages_4","text":"Resolution Request: The Requester broadcasts a message which may or may not contain a DID. Resolution Result: If the message contains a DID, the Resolver resolves the DID and returns the DID Resolution Result . Otherwise, the Resolver returns the result of resolving it's own DID. This is intended for the special case of \"local\" DID methods, which do not have a globally resolvable state.","title":"Messages"},{"location":"guides/interaction_flows/#examples_4","text":"A simple Peer Resolution flow between our two Agents from the Identity Management example looks as follows: Alice creates a resolution request: const aliceResRequest = await alice.createResolutionRequest({ description: 'introduce yourself', callbackURL: 'https://example.com/onboarding', }) Alices request is received by Bob (by some means, e.g. QR code) and processed: const bobsInteraction = await bob.processJWT(aliceResRequest) const bobsResResponse = await bobsInteraction.createResolutionResponse() await bob.processJWT(bobsResResponse.encode()) Bob's response is received by Alice (e.g. via POSTing to the callbackURL ): // this adds Bob's identity data (a Key Event Log) to Alice's storage, such that she can now resolve his DID and verify signatures made by him const alicesInteraction = await alice.processJWT(bobsResResponse.encode())","title":"Examples"},{"location":"guides/sdk_install_conf/","text":"Installation and configuration The following sections will briefly describe how to add the Jolocom SDK to your project, as well as briefly outline some of the exposed configuration options (e.g. how to add / remove / switch between DID methods). Installing the Jolocom SDK In order to be able to install and run the Jolocom SDK, Node.js v10 is required. Depending on your package manager, you can simply run: npm i @jolocom/sdk jolocom-lib # In case you use yarn yarn add @jolocom/sdk jolocom-lib In case you would like to avoid implementing a custom storage backend for the SDK, the @jolocom/sdk-storage-typeorm module should be installed at this point as well. Instantiating the Jolocom SDK The Jolocom SDK requires a set of external services that provide storage and network transports integrations appropriate to the runtime environment. The Storage module is required on instantiation, while network transports are configured (and can be reconfigured) after an SDK instance is created. Storage A storage module is required to persist data (e.g. DID Documents, Verifiable Credentials, Encrypted keys, etc) which is generated or collected as part of various SSI interactions and events. Custom storage backend implementations can be defined, as long as they satisfy the IStorage interface. The fastest way to get a compliant storage module is by using the @jolocom/sdk-storage-typeorm module: import { JolocomSDK, NaivePasswordStore } from '@jolocom/sdk' import { JolocomTypeormStorage } from '@jolocom/sdk-storage-typeorm' import { createConnection } from 'typeorm' const typeOrmConfig = { name: 'demoDb', type: 'sqlite', database: ':memory:', dropSchema: true, entities: ['node_modules/@jolocom/sdk-storage-typeorm/js/src/entities/*.js'], synchronize: true, logging: false, } const connection = await createConnection(typeOrmConfig) const sdk = new JolocomSDK({ storage: new JolocomTypeormStorage(connection), }) An additional optional argument, eventDB , can be provided to the constructor to specify a custom storage backend for \"events\" encountered as part of Peer-Resolution flows . This DB will only be used for particular DID methods. In case no argument is passed, the storage argument is used instead. Network Transports The SDK currently supports WebSockets and HTTP as data transports. These need to be configured prior to usage, to inject platform specific solutions. HTTP The HTTP transport simply requires an implementation of fetch . For Node environments, install node-fetch and it will be automatically configured. Or to use your custom fetch implementation: sdk.transports.http.configure({ fetch: customFetchImplementation }) WebSocket The WebSocket transport requires an implementation of WebSocket . In Node environments, to use ws as the WebSocket implementation, install the pacakge then after instantiating the SDK in your code: import * as WebSocket from 'ws' /* .... instantiate SDK .... */ sdk.transports.ws.configure({ WebSocket })","title":"Installation and configuration"},{"location":"guides/sdk_install_conf/#installation-and-configuration","text":"The following sections will briefly describe how to add the Jolocom SDK to your project, as well as briefly outline some of the exposed configuration options (e.g. how to add / remove / switch between DID methods).","title":"Installation and configuration"},{"location":"guides/sdk_install_conf/#installing-the-jolocom-sdk","text":"In order to be able to install and run the Jolocom SDK, Node.js v10 is required. Depending on your package manager, you can simply run: npm i @jolocom/sdk jolocom-lib # In case you use yarn yarn add @jolocom/sdk jolocom-lib In case you would like to avoid implementing a custom storage backend for the SDK, the @jolocom/sdk-storage-typeorm module should be installed at this point as well.","title":"Installing the Jolocom SDK"},{"location":"guides/sdk_install_conf/#instantiating-the-jolocom-sdk","text":"The Jolocom SDK requires a set of external services that provide storage and network transports integrations appropriate to the runtime environment. The Storage module is required on instantiation, while network transports are configured (and can be reconfigured) after an SDK instance is created.","title":"Instantiating the Jolocom SDK"},{"location":"guides/sdk_install_conf/#storage","text":"A storage module is required to persist data (e.g. DID Documents, Verifiable Credentials, Encrypted keys, etc) which is generated or collected as part of various SSI interactions and events. Custom storage backend implementations can be defined, as long as they satisfy the IStorage interface. The fastest way to get a compliant storage module is by using the @jolocom/sdk-storage-typeorm module: import { JolocomSDK, NaivePasswordStore } from '@jolocom/sdk' import { JolocomTypeormStorage } from '@jolocom/sdk-storage-typeorm' import { createConnection } from 'typeorm' const typeOrmConfig = { name: 'demoDb', type: 'sqlite', database: ':memory:', dropSchema: true, entities: ['node_modules/@jolocom/sdk-storage-typeorm/js/src/entities/*.js'], synchronize: true, logging: false, } const connection = await createConnection(typeOrmConfig) const sdk = new JolocomSDK({ storage: new JolocomTypeormStorage(connection), }) An additional optional argument, eventDB , can be provided to the constructor to specify a custom storage backend for \"events\" encountered as part of Peer-Resolution flows . This DB will only be used for particular DID methods. In case no argument is passed, the storage argument is used instead.","title":"Storage"},{"location":"guides/sdk_install_conf/#network-transports","text":"The SDK currently supports WebSockets and HTTP as data transports. These need to be configured prior to usage, to inject platform specific solutions.","title":"Network Transports"},{"location":"guides/sdk_install_conf/#http","text":"The HTTP transport simply requires an implementation of fetch . For Node environments, install node-fetch and it will be automatically configured. Or to use your custom fetch implementation: sdk.transports.http.configure({ fetch: customFetchImplementation })","title":"HTTP"},{"location":"guides/sdk_install_conf/#websocket","text":"The WebSocket transport requires an implementation of WebSocket . In Node environments, to use ws as the WebSocket implementation, install the pacakge then after instantiating the SDK in your code: import * as WebSocket from 'ws' /* .... instantiate SDK .... */ sdk.transports.ws.configure({ WebSocket })","title":"WebSocket"},{"location":"visuals/codeflower/","text":"CodeFlower This experiment visualizes source repositories using an interactive tree. Each disc represents a file, with a radius proportional to the number of lines of code (loc). All rendering is done client-side, in JavaScript. Built with d3.js , inspired by Code Swarm and Gource , published with the MIT open-source license. Interact with CodeFlowers, see examples, and build your own at http://fzaninotto.github.com/CodeFlower . You might also like DependencyWheel , another d3.js visualization for indirect dependencies in software packages.","title":"Index"},{"location":"visuals/codeflower/#codeflower","text":"This experiment visualizes source repositories using an interactive tree. Each disc represents a file, with a radius proportional to the number of lines of code (loc). All rendering is done client-side, in JavaScript. Built with d3.js , inspired by Code Swarm and Gource , published with the MIT open-source license. Interact with CodeFlowers, see examples, and build your own at http://fzaninotto.github.com/CodeFlower . You might also like DependencyWheel , another d3.js visualization for indirect dependencies in software packages.","title":"CodeFlower"},{"location":"visuals/depwheel/","text":"Dependency Wheel This experiment visualizes package dependencies using an interactive disc. Each disc section represents a dependency, and links between arcs materialize these dependencies. All rendering is done client-side, in JavaScript. Built with d3.js , published with the MIT open-source license. Interact with DependencyWheels, see examples, and build your own at http://fzaninotto.github.com/DependencyWheel .","title":"Index"},{"location":"visuals/depwheel/#dependency-wheel","text":"This experiment visualizes package dependencies using an interactive disc. Each disc section represents a dependency, and links between arcs materialize these dependencies. All rendering is done client-side, in JavaScript. Built with d3.js , published with the MIT open-source license. Interact with DependencyWheels, see examples, and build your own at http://fzaninotto.github.com/DependencyWheel .","title":"Dependency Wheel"}]}